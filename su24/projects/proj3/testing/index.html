<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="language" content="english">
<title>Appendix: Testing and Debugging | CS 61C Summer 2024</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="light dark">
<link rel="shortcut icon" type="image/png" href="../../../img/favicon.png">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/5.1.3/css/bootstrap.min.css" integrity="sha512-GQGU0fMMi238uA+a/bdWJfpUGKUkBdgfFdgBm72SUQ6BeyWjoY/ton0tEjH+OSH9iP4Dfh+7HM0I9f5eR0L/4w==" crossorigin="anonymous" referrerpolicy="no-referrer" />
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/5.1.3/js/bootstrap.min.js" integrity="sha512-OvBgP9A2JBgiRad/mM36mkzXSXaJE9BEIENnVEmeZdITvwT09xnxLtT4twkCa8m/loMbPHsvPl0T8lRGVBwjlQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/instant.page/5.1.0/instantpage.min.js" integrity="sha512-1+qUtKoh9XZW7j+6LhRMAyOrgSQKenQ4mluTR+cvxXjP1Z54RxZuzstR/H9kgPXQsVB8IW7DMDFUJpzLjvhGSQ==" crossorigin="anonymous"></script>
<link rel="stylesheet" href="../../../css/main.css@h=c5951e6c6fad5a9be897b57166a91a9f096ce6af0a0da724899f2b57a97006a6.css" />
<script defer type="text/javascript" src="../../../js/main.js@h=e9256ad8bb73d1000c4167f68a3255ff61b7276031d009594ea6f4066e941fba"></script>

<script type="text/javascript" src="../../../js/main-sync.js@h=a5a9607bf30db01764e4c92a4d4832318d20ec7d3ec29af4ddf72b7ddcb13817"></script>
<script>initDarkToggle();</script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.17.0/tocbot.min.js" integrity="sha512-DJhUMo5TIBb3fFziiE+3OJG+j7ky+GxScxHdLADCXskEpc/AKQsbsorIYmGFJFaJvDIyP65rJNhnCTytfYAdUw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-dark mb-4">
<div class="container">
<a class="navbar-brand" href="../../../../index.html">
<img class="d-inline-block me-2 rounded" height="48" width="48" src="../../../img/icon-small.png" alt="outline of square computer chip with cs61c label" />
<span class="align-middle">CS 61C Summer 2024</span>
</a>
<button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarContent" aria-controls="navbarContent" aria-expanded="false" aria-label="Toggle Navigation">
<span class="navbar-toggler-icon"></span>
</button>
<div class="collapse navbar-collapse" id="navbarContent">
<ul class="navbar-nav me-auto mb-2 mb-lg-0">
<li class="nav-item">
<a class="nav-link" href="../../../calendar/index.html">Calendar</a>
</li>
<li class="nav-item">
<a class="nav-link" href="../../../staff/index.html">Staff</a>
</li>
<li class="nav-item">
<a class="nav-link" href="../../../exam/index.html">Exam</a>
</li>
<li class="nav-item">
<a class="nav-link" href="../../../policies/index.html">Policies</a>
</li>
<li class="nav-item">
<a class="nav-link" href="../../../resources/index.html">Resources</a>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href="index.html#" id="navbarLinksDropdownToggle" role="button" data-bs-toggle="dropdown" aria-expanded="false">Quick Links</a>
<ul class="dropdown-menu p-0" aria-labelledby="navbarLinksDropdownToggle">
<li><a class="dropdown-item nav-link" href="../../../pdfs/resources/reference-card.pdf">Reference Card</a></li>
<li><a class="dropdown-item nav-link" href="https://oh.cs61c.org/">OH Queue</a></li>
<li><a class="dropdown-item nav-link" href="https://venus.cs61c.org/">Venus</a></li>
<li><a class="dropdown-item nav-link" href="https://inst.eecs.berkeley.edu/~cs61c/archives.html">Past Semesters</a></li>
</ul>
</li>
</ul>
</div>
</div>
</nav>
<main class="mb-4">
<section class="section">
<div class="container">
<div class="row spec">
<nav class="col-md-3 d-print-none sticky-md-top nav-wrapper" aria-label="table of contents">
<ul class="nav flex-column">
<li class="nav-item">
<a class="nav-link" href="../index.html">Project 3: CS61CPU</a>
</li>
<li class="nav-item">
<a class="nav-link" href="../control-logic/index.html">Appendix: Control Logic</a>
</li>
<li class="nav-item">
<a class="nav-link" href="index.html">Appendix: Testing and Debugging</a>
<div id="toc-wrapper">
<ul class="nav flex-column">
<li class="nav-item">
<a class="nav-link" href="index.html#unit-tests">Unit Tests</a>
<ul class="nav flex-column">
<li class="nav-item">
<a class="nav-link" href="index.html#viewing-output-files">Viewing Output Files</a>
</li>
<li class="nav-item">
<a class="nav-link" href="index.html#using-debugging-circuits">Using Debugging Circuits</a>
</li>
</ul>
</li>
<li class="nav-item">
<a class="nav-link" href="index.html#integration-tests">Integration Tests</a>
<ul class="nav flex-column">
<li class="nav-item">
<a class="nav-link" href="index.html#viewing-testing-code">Viewing Testing Code</a>
</li>
<li class="nav-item">
<a class="nav-link" href="index.html#reading-test-output">Reading Test Output</a>
</li>
<li class="nav-item">
<a class="nav-link" href="index.html#reading-jump-branch-test-output">Reading Jump&#x2F;Branch Test Output</a>
</li>
<li class="nav-item">
<a class="nav-link" href="index.html#opening-debugging-circuits">Opening Debugging Circuits</a>
</li>
<li class="nav-item">
<a class="nav-link" href="index.html#time-step-counter">Time Step Counter</a>
</li>
<li class="nav-item">
<a class="nav-link" href="index.html#using-debugging-circuits-1">Using Debugging Circuits</a>
</li>
</ul>
</li>
<li class="nav-item">
<a class="nav-link" href="index.html#writing-integration-tests">Writing Integration Tests</a>
</li>
<li class="nav-item">
<a class="nav-link" href="index.html#logisim-tips">Logisim Tips</a>
<ul class="nav flex-column">
<li class="nav-item">
<a class="nav-link" href="index.html#wiring">Wiring</a>
</li>
<li class="nav-item">
<a class="nav-link" href="index.html#wiring-pitfalls">Wiring Pitfalls</a>
</li>
<li class="nav-item">
<a class="nav-link" href="index.html#subcircuits">Subcircuits</a>
</li>
<li class="nav-item">
<a class="nav-link" href="index.html#signal-tips">Signal Tips</a>
</li>
<li class="nav-item">
<a class="nav-link" href="index.html#banned-circuit-elements">Banned Circuit Elements</a>
</li>
</ul>
</li>
</ul>
</div>
</li>
<li class="nav-item">
<a class="nav-link" href="../partial-load-store/index.html">Appendix: Partial Loads and Stores</a>
</li>
</ul>
</nav>
<div id="toc-content-wrapper" class="content col-md-9">
<h1>Appendix: Testing and Debugging</h1>
<h2 id="unit-tests">Unit Tests</h2>
<p>The provided unit tests check functionality of your subcircuits (e.g. immediate generator, branch comparator). They do not check your entire CPU implementation. You don't need to write any unit tests yourself.</p>
<p>As an example, let's debug the <code>alu-add</code> unit test. First, <strong>run the ALU unit tests with <code>bash test.sh test_alu</code></strong>. If the test doesn't pass, this will print out the difference between your subcircuit output and the reference output.</p>
<h3 id="viewing-output-files">Viewing Output Files</h3>
<p>The next step to debug unit tests is to compare the expected reference output to your subcircuit output. These output files will always be in the <code>out</code> directory. You can use <code>bash test.sh format filename</code> (replacing <code>filename</code>) to view the output files.</p>
<p><strong>View the reference output with <code>bash test.sh format tests/unit-alu/out/alu-add.ref</code></strong>. You should see this reference output:</p>
<pre class="z-code"><code><span class="z-text z-plain">Time ALUSel A        B        ALUResult
00   0      00002020 00000f0f 00002f2f 
01   0      ffffdead ffffbeef ffff9d9c 
02   0      00007fff 00000001 00008000 
03   0      00000000 00000000 00000000 
</span></code></pre>
<p>This shows the inputs (<code>A</code>, <code>B</code>, and <code>ALUSel</code>) sent to your subcircuit at each time step, and the expected output (<code>ALUResult</code>).</p>
<p>Next, <strong>run <code>bash test.sh format tests/unit-alu/out/alu-add.out</code> to see the output from your subcircuit</strong>. Here's the output when the test is run on unmodified starter code:</p>
<pre class="z-code"><code><span class="z-text z-plain">Time ALUSel A        B        ALUResult
00   0      00002020 00000f0f UUUUUUUU 
01   0      ffffdead ffffbeef UUUUUUUU 
02   0      00007fff 00000001 UUUUUUUU 
03   0      00000000 00000000 UUUUUUUU 
</span></code></pre>
<p>Note that in the example, the inputs to your subcircuit are the same, but the output (<code>ALUResult</code>) of your subcircuit is different (undefined).</p>
<h3 id="using-debugging-circuits">Using Debugging Circuits</h3>
<p>Each unit test has a <code>.circ</code> test circuit you can use for debugging. As an example, <strong>open <code>tests/unit-alu/alu-add.circ</code></strong>, which corresponds to the failed test from the previous section. The first thing you'll see in this circuit is the testing harness:</p>
<p><img src="../alu-add-1.png" alt="Annotated screenshot of alu-add.circ." /></p>
<p>This feeds a sequence of inputs (<code>InputA</code>, <code>InputB</code>, and <code>ALUSel</code>) to your ALU.</p>
<p>The ROM (in the red box) contains a list of inputs to your circuit. The first input (<code>InputA = 0x00002020</code>, <code>InputB = 0x00000f0f</code>, <code>ALUSel = 0b0000</code>) is highlighted in dark gray. You can also see these values being passed into your ALU (in the blue box) with the probes.</p>
<p>In this picture, the <code>ALUResult</code> output from your ALU is undefined (all <code>U</code>s). To see why, we can view our ALU subcircuit to see what logic it's doing. To click into your ALU, you can either <strong>right-click the ALU</strong> and <strong>select &quot;View alu&quot;</strong>, or <strong>click the ALU</strong> and <strong>click the magnifying glass</strong>, as shown below:</p>
<p><img src="../alu-add-2.png" alt="Using the magnifying glass to click into a subcircuit." /></p>
<p><img src="../alu-add-3.png" alt="Right-clicking to click into a subcircuit." /></p>
<p>Inside your ALU subcircuit, you can see inputs (<code>A</code>, <code>B</code>, and <code>ALUSel</code>) provided from the harness to your subcircuit. You can <strong>click on wires to see the values in those wires.</strong></p>
<p><img src="../alu-add-4.png" alt="Clicking on wires inside alu.circ to debug." /></p>
<p>If the output of your subcircuit isn't what you expect, you can probe wires to investigate where the incorrect output is coming from. In the starter circuit, the <code>ALUResult</code> output is undefined. In this case, note that the <code>ALUResult</code> tunnel is undefined, so we probably want to send a value to this tunnel.</p>
<p>To return to the harness, you can click on <code>main</code> in the Simulate → Active Simulations tab in the top-left corner.</p>
<p><strong>To view later inputs, click Simulate → Manual Tick Full Cycle</strong>, which will highlight the next row of the ROM blocks and send this next input into your subcircuit. You can tick cycles while viewing your ALU subcircuit to see later inputs.</p>
<p><strong>To reset the simulation, click Simulate → Reset Simulator</strong>. You can also close and re-open the debugging circuit.</p>
<h2 id="integration-tests">Integration Tests</h2>
<p>Integration tests execute RISC-V instructions on your entire CPU and compare the outputs to the result of running those instructions on Venus. You'll need to make your own integration tests by writing out RISC-V instructions (the testing framework will then create the testing and debugging circuit for you).</p>
<p>In addition to the example below, please check out <a href="https://www.youtube.com/watch?v=EgnrLisk9J0">this video</a> regarding writing integration tests.</p>
<p>As an example, let's debug the <code>addi-basic</code> unit test. First, <strong>run the addi integration tests with <code>bash test.sh test_addi</code></strong>. If the test doesn't pass, this will print out the difference between your CPU output and the reference output.</p>
<h3 id="viewing-testing-code">Viewing Testing Code</h3>
<p>Before we can figure out why this test failed, we should first figure out what code this test tried to run on your CPU.</p>
<p>The RISC-V instructions being executed by your CPU will be inside the <code>in</code> directory. In this example, <strong>view <code>tests/integration-addi/in/addi-basic.s</code></strong> to see what RISC-V instructions are being run in this test. You should see these instructions:</p>
<pre class="z-code"><code><span class="z-text z-plain">addi t0, x0, 1
addi t0, x0, 42
addi t0, x0, 256
addi t0, x0, 2047
</span></code></pre>
<h3 id="reading-test-output">Reading Test Output</h3>
<p>If an integration test fails, you should see some terminal output like this:</p>
<pre class="z-code"><code><span class="z-text z-plain">$ bash test.sh test_addi
FAIL: tests/integration-addi/addi-basic.circ (Did not match expected output)
             Time PC       Instruc. ra (x1)  sp (x2)  t0 (x5)  t1 (x6)  t2 (x7)  s0 (x8)  s1 (x9)  a0 (x10)
  Reference: 0001 00000004 02a00293 00000000 00000000 00000001 00000000 00000000 00000000 00000000 00000000
  Student:   0001 00000004 02a00293 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
  ---
  Reference: 0002 00000008 10000293 00000000 00000000 0000002a 00000000 00000000 00000000 00000000 00000000
  Student:   0002 00000008 10000293 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
  ---
  Reference: 0003 0000000c 7ff00293 00000000 00000000 00000100 00000000 00000000 00000000 00000000 00000000
  Student:   0003 0000000c 7ff00293 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
  ---
</span></code></pre>
<p>Each row of output shows the program counter (PC), instruction, and values in the 8 debug registers at each time step of running the input program.</p>
<p>You might see a lot of rows of output, but let's <strong>focus on the first two rows</strong>, which shows the first time step when your CPU doesn't match the reference output. In this case, that's time step 1.</p>
<p>In the first set of Reference/Student output, <strong>look for registers with mismatched values</strong>. In the above output, it looks like t0 should hold the value 1, but in your CPU, t0 holds the value 0.</p>
<p>Using the terminal output and the RISC-V code, try to work out what failed on the time step immediately before the first failing time step. In this output, since incorrect output showed up at time 1, something must have gone wrong at time 0. At time 0, the RISC-V code executed <code>addi t0, x0, 1</code> - now we can see why the reference output has a 1 in t0. However, our implementation did not put a 1 in t0, so it looks like the very first <code>addi</code> instruction didn't execute correctly.</p>
<h3 id="reading-jump-branch-test-output">Reading Jump/Branch Test Output</h3>
<p>In tests like <code>addi-basic</code>, the RISC-V instructions execute in sequence, so it's simple to work out which instruction failed. For example, if the first line of terminal output shows time step <code>0003</code>, you know that the instruction at time step 2 failed, and this instruction must be <code>addi t0, x0, 256</code> (the second instruction in the testing code, zero-indexed).</p>
<p>However, when we're running code with jumps and branches, the RISC-V instructions don't execute in sequence, so we have to be more careful to figure out which instruction failed. Consider the output below:</p>
<pre class="z-code"><code><span class="z-text z-plain">$ bash test.sh test_integration_branch
FAIL: tests/integration-branch/branch-basic.circ (Did not match expected output)
             Time PC       Instruc. ra (x1)  sp (x2)  t0 (x5)  t1 (x6)  t2 (x7)  s0 (x8)  s1 (x9)  a0 (x10)
  Reference: 0005 00000018 fe948ce3 00000000 00000000 00000000 00000000 00000000 ffffffff 00000001 00000000
  Student:   0005 00000024 fe944ce3 00000000 00000000 00000000 00000000 00000000 ffffffff 00000001 00000000
  ---
  Reference: 0006 00000010 fe04cce3 00000000 00000000 00000000 00000000 00000000 ffffffff 00000001 00000000
  Student:   0006 00000028 fe000ce3 00000000 00000000 00000000 00000000 00000000 ffffffff 00000001 00000000
  ---
  Reference: 0007 00000014 fe000ce3 00000000 00000000 00000000 00000000 00000000 ffffffff 00000001 00000000
  Student:   0007 00000020 fe904ce3 00000000 00000000 00000000 00000000 00000000 ffffffff 00000001 00000000
  ---
</span></code></pre>
<p>We know that the instruction at time step 4 failed, but which instruction is that? Let's check the RISC-V code in <code>tests/integration-branch/in/branch-basic.s</code>:</p>
<pre class="z-code"><code><span class="z-text z-plain">         addi s1, x0, 1
         addi s0, x0, -1
label5:  beq  x0, x0, label1
label6:  bltu x0, s0, label8
label4:  blt  s1, x0, label5
         beq  x0, x0, label6
label3:  beq  s1, s1, label4
label10: beq  s0, s0, end
label2:  blt  x0, s1, label3
label9:  blt  s0, s1, label10
label1:  beq  x0, x0, label2
label8:  bltu s1, s1, label9
         beq  s1, s1, label9
end:     addi s0, x0, 2
</span></code></pre>
<ul>
<li>At time step 0, <code>addi s1 x0 1</code> executes.</li>
<li>At time step 1, <code>addi s0 x0 -1</code> executes.</li>
<li>At time step 2, <code>beq x0 x0 label1</code> executes, causing a branch to be taken.</li>
<li>At time step 3, <code>beq x0 x0 label2</code> (the line at <code>label1</code>) executes, causing a branch to be taken.</li>
<li>At time step 4, <code>blt x0 s1 label3</code> (the line at <code>label2</code>) executes.</li>
</ul>
<p>At time step 4, s1 holds 1, so the branch at time step 4 should be taken. This means at time step 5, we should be executing the instruction at <code>label3</code>. This is the 6th instruction (zero-indexed), which corresponds to PC value 24 (each instruction is 4 bytes), which is 0x18 (the value under PC in the reference output).</p>
<p>However, in our output, the PC is at 0x24, or 36 in decimal. This is the 9th instruction, which is <code>label9</code> (the line directly after <code>label2</code>). It looks like at time step 4, the branch instruction should have updated the PC by taking a branch, but in our implementation, the PC was updated incorrectly.</p>
<h3 id="opening-debugging-circuits">Opening Debugging Circuits</h3>
<p>Each integration test has a <code>.circ</code> test circuit you can use for debugging. To debug the example test from the previous section, <strong>open tests/integration-addi/addi-basic.circ</strong>.</p>
<p><img src="../addi-basic-1.png" alt="Screenshot of addi-basic.circ." /></p>
<p>The top-level harness for each integration test contains a ROM block (bottom half of screenshot) containing the RISC-V instructions for that test, representing IMEM (instruction memory). These instructions are passed into your CPU (the circled <code>cpu_harness</code> block at the top). You can also see the 8 debug register outputs; the testing framework will log their values into the <code>.out</code> file when running the test.</p>
<p>To view your CPU circuit, either <strong>right-click the <code>cpu_harness</code> block</strong> and <strong>select &quot;View cpu_harness&quot;</strong>, or <strong>click the <code>cpu_harness</code> block</strong> and <strong>click the magnifying glass</strong>. This takes you into the CPU harness, where your CPU interacts with memory. <strong>Click another time into the <code>cpu</code> block</strong>, and now you should see the CPU you've been wiring.</p>
<p><strong>To step through the RISC-V instructions, click Simulate → Manual Tick Full Cycle</strong>. In each clock cycle, your CPU will output a new <code>ProgramCounter</code> to the harness, which will use the new PC to select the next instruction for your CPU to execute. In this <code>addi</code> test, the instructions execute in sequence, but when testing branches and jumps later, the CPU could output a different <code>ProgramCounter</code> value (not always adding 4) and execute the instructions in a different order.</p>
<p><strong>To reset the simulation, click Simulate → Reset Simulator</strong>. You can also close and re-open the debugging circuit.</p>
<h3 id="time-step-counter">Time Step Counter</h3>
<p>When instructions don't execute in sequence, it can be hard to figure out how many cycles to tick before you reach the first failing instruction. To make that easier, we recommend adding a small counter circuit to your <code>cpu.circ</code> circuit:</p>
<p><img src="../timestep-counter.png" alt="Basic circuit that adds 1 at each time step." /></p>
<p>This is the same logic as the PC circuit in the starter code, except the counter circuit adds 1 at each time step instead of adding 4. Also, the <code>ProgramCounter</code> tunnel has been replaced with a Probe that lets you view the value of the wire while debugging.</p>
<p>This counter circuit is only here for debugging, not for your CPU implementation. When you modify your PC circuit to handle jumps and branches, this counter circuit will still be adding 1 at every time step, allowing you to keep track of when the first failing instruction occurs.</p>
<p>Now, you can use this counter to stop at the first failing instruction. For example, if your terminal output looks like this:</p>
<pre class="z-code"><code><span class="z-text z-plain">$ bash test.sh test_integration_branch
FAIL: tests/integration-branch/branch-basic.circ (Did not match expected output)
             Time PC       Instruc. ra (x1)  sp (x2)  t0 (x5)  t1 (x6)  t2 (x7)  s0 (x8)  s1 (x9)  a0 (x10)
  Reference: 0006 00000010 fe04cce3 00000000 00000000 00000000 00000000 00000000 ffffffff 00000001 00000000
  Student:   0006 00000028 fe000ce3 00000000 00000000 00000000 00000000 00000000 ffffffff 00000001 00000000
  ---
  Reference: 0007 00000014 fe000ce3 00000000 00000000 00000000 00000000 00000000 ffffffff 00000001 00000000
  Student:   0007 00000020 fe904ce3 00000000 00000000 00000000 00000000 00000000 ffffffff 00000001 00000000
  ---
</span></code></pre>
<p>You know that the instruction at time step 5 failed, so you should go into the debugging circuit and tick the clock until the counter circuit is showing 5. Now, you can start poking around to see what instruction is currently executing, and why it's failing.</p>
<h3 id="using-debugging-circuits-1">Using Debugging Circuits</h3>
<p>At this point, you should have identified which RISC-V instruction is failing on your circuit, the expected register values after that instruction, and your register values after that instruction. You should have also opened a debugging circuit and ticked the clock until the failing instruction. Now, it's time to poke at all the wires in your circuit to see why this instruction is failing.</p>
<p>Some useful wires you can poke:</p>
<ul>
<li>If the instruction writes back to a register: which RegFile input corresponds to the data we're writing on this cycle?</li>
<li>If the instruction uses the ALU for computation: what are the three inputs (A, B, and ALUSel) to the ALU, and are they what you expect? What is the output from the ALU, and is it what you expect?</li>
<li>If the instruction is a branch/jump: what value is getting written to the PC register on the next clock cycle? Is that value what you expect? Which control logic signal determines the value written to the PC register? Does that signal have the right value?</li>
<li>If the instruction is a store/load instruction: what are the three inputs to DMEM, and are they what you expect? What is the output from DMEM, and is it what you expect?</li>
</ul>
<p>Note: If the failing instruction is a load instruction, it could be the case that your store instruction failed to write to DMEM first, and now the load instruction can't read a value that was never written to DMEM. In this case, you might want to stop at store instructions too and check that they're working as you expect.</p>
<h2 id="writing-integration-tests">Writing Integration Tests</h2>
<p>To write an integration test, all you need to do is write some RISC-V instructions for your CPU to run, and the testing framework will handle the rest.</p>
<ol>
<li>Navigate to <code>tests/integration-custom/in</code>.</li>
<li>Write a RISC-V test and save it in a filename ending in <code>.s</code>.</li>
<li>Run <code>bash test.sh test_custom</code>.</li>
</ol>
<p>Some things to keep in mind when writing your RISC-V instructions:</p>
<p>The testing framework only checks the values in the 8 debug registers when comparing your CPU output with the reference output, so when writing your own tests, make sure to only use the 8 debug registers.</p>
<p>This also means the testing framework doesn't check memory (DMEM) when comparing your CPU with the reference. To check values in memory or a non-debug register, you'll need to put the value back into a debug register. For example, to test if a store works, you'll probably have to load the value back from memory into a debug register to see if the value was successfully stored.</p>
<p>IMEM and DMEM are separate in Logisim, but combined in Venus. This means that if you write assembly code that tries to access memory overlapping with instructions, Venus will throw an error. Since counting exactly how many instructions your assembly code requires, and multiplying that by 4 can be annoying, we suggest you load/store using addresses greater than 0x3E8 (leaving space for 1000 bytes/250 instructions), and increase this offset if you have more instructions.</p>
<p>Make sure to write RISC-V instructions that behave differently on a working CPU and a buggy CPU. For example, consider this test:</p>
<pre class="z-code"><code><span class="z-text z-plain">addi t0, x0, 0
addi t1, x0, 0
</span></code></pre>
<p>This wouldn't be very useful to check for a working CPU, because the output in the debugging registers could be all zeros even if your CPU doesn't work. As another example:</p>
<pre class="z-code"><code><span class="z-text z-plain">beq t0, t0, 4
addi t1, x0, 10
</span></code></pre>
<p>On a working CPU, this would branch to the <code>addi</code> instruction. On a buggy CPU where the branch is incorrectly not taken, this would still execute the <code>addi</code> instruction, so this test doesn't do a very good job of distinguishing working circuits from buggy circuits.</p>
<h2 id="logisim-tips">Logisim Tips</h2>
<p>This section contains some helpful Logisim tips and pitfalls to avoid.</p>
<h3 id="wiring">Wiring</h3>
<ul>
<li>If you want to know more details about each component, go to <code>Help -&gt; Library Reference</code> for more information on the component and its inputs and outputs.</li>
<li>Use tunnels! They will make your wiring cleaner and easier to follow, and will reduce your chances of encountering crossed wires or unexpected errors.</li>
<li>Ensure you name your tunnels correctly. The labels are case sensitive!</li>
<li>You can hover your cursor over an input/output on a component to get slightly more information about that input/output.</li>
</ul>
<h3 id="wiring-pitfalls">Wiring Pitfalls</h3>
<ul>
<li>Your circuits should always fit in the provided harnesses. This means that you should not edit the provided input/output pins or add new ones. To ensure your circuit fits int he harness, you can open the harnesses in the <code>harnesses</code> folder and check that there are no errors.</li>
<li>Don't create new <code>.circ</code> files. You can make additional subcircuits if you want, but they must be in existing files.</li>
</ul>
<h3 id="subcircuits">Subcircuits</h3>
<ul>
<li>Note that if you modify a subcircuit, and another circuit file uses that subcircuit, you will need to close and re-open the outer circuit to load the changes from the subcircuit. For example, if you modify <code>imm-gen.circ</code>, you should close and re-open <code>cpu.circ</code> to load your changes.</li>
<li>When modifying a subcircuit, you should always open up the subcircuit file. For example, you should modify <code>imm-gen.circ</code>, not the <code>imm-gen</code> subcircuit in <code>cpu.circ</code>.</li>
</ul>
<h3 id="signal-tips">Signal Tips</h3>
<ul>
<li>The clock input signal (<code>clk</code>) can be sent into subcircuits or attached directly to the clock inputs of memory units in Logisim, but should not otherwise be gated (i.e., do not invert it, do not <code>AND</code> it with anything, etc.).</li>
<li>We recommend not using the <code>Enable</code> input on your MUXes. In fact, you can turn that attribute off (<code>Include Enable?</code>). We also recommend that you disable the <code>Three-state?</code> attribute (if the plexer has it).</li>
</ul>
<h3 id="banned-circuit-elements">Banned Circuit Elements</h3>
<p>The following circuit elements are not necessary for this project, so please don't use them in your implementation.</p>
<ul>
<li>Pull Resistor</li>
<li>Transistor</li>
<li>Transmission Gate</li>
<li>Power</li>
<li>POR</li>
<li>Ground</li>
<li>Divider</li>
<li>Random</li>
<li>PLA</li>
<li>RAM</li>
<li>Random Generator</li>
</ul>
</div>
</div>
</div>
</section>
</main>
<footer>
<div class="container border-top pt-4 mb-5">
<div class="row">
<div class="col">
<div id="dark-toggle-wrapper" class="d-none">
<div class="form-check form-switch">
<input id="inputDarkToggle" class="form-check-input" type="checkbox">
<label class="form-check-label" for="inputDarkToggle">
Dark Mode
<a id="buttonDarkToggleReset" class="d-none" href="javascript:void(0);">(reset)</a>
</label>
</div>
</div>
</div>
</div>
</div>
</footer>
<script>
  

  document.addEventListener("DOMContentLoaded", function() {
    initToC();
  });
</script>
</body>
</html>
